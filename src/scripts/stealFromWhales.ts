import { ERC20__factory } from "src/types/factories/ERC20__factory";import { ethers, waffle } from "hardhat";import { ERC20 } from "src/types/ERC20";import { impersonate, stopImpersonating } from "src/helpers/impersonate";import { BigNumber } from "ethers";const { provider } = waffle;const whales: { [k in string]: string } = {  stCRV: "0x56c915758Ad3f76Fd287FFF7563ee313142Fb663",  stETH: "0x06920C9fC643De77B99cB7670A944AD31eaAA260",  crvTriCrypto: "0x26026fec6af3404a2d00918891966330bc2f36c8",  USDT: "0x47ac0Fb4F2D84898e4D9E7b4DaB3C24507a6D503",  WBTC: "0xE3DD3914aB28bB552d41B8dFE607355DE4c37A51",  WETH: "0x2fEb1512183545f48f6b9C5b4EbfCaF49CfCa6F3",  LUSD3CRV_F: "0x3631401a11ba7004d1311e24d177b05ece39b4b3",  LUSD: "0xE05fD1304C1CfE19dcc6AAb0767848CC4A8f54aa",  "3Crv": "0x0B096d1f0ba7Ef2b3C7ecB8d4a5848043CdeBD50",  DAI: "0x47ac0Fb4F2D84898e4D9E7b4DaB3C24507a6D503",  USDC: "0xdb49552EeFB89416b9A412138c009a004f54BAd0",};const tokens: { [k in string]: string } = {  DAI: "0x6B175474E89094C44Da98b954EedeAC495271d0F",  STETH: "0xae7ab96520de3a18e5e111b5eaab095312d7fe84",};const setStorageAt = async (address: string, index: string, value: string) => {  await ethers.provider.send("hardhat_setStorageAt", [address, index, value]);  await ethers.provider.send("evm_mine", []); // Just mines to the next block};async function transferERC20(  token: ERC20,  recipient: string,  amount: BigNumber) {  return await token.transfer(recipient, amount);}const toBytes32 = (bn: BigNumber) => {  return ethers.utils.hexlify(ethers.utils.zeroPad(bn.toHexString(), 32));};const slotLimit = 10;async function main() {  const [signer, { address: recipientAddress }] = await ethers.getSigners();  const DAI = ERC20__factory.connect(tokens["DAI"], signer);  const balance = await DAI.balanceOf(recipientAddress);  console.log(ethers.utils.formatEther(balance));  for (let i = 0; i < slotLimit; i++) {    const d = await provider.getStorageAt(      DAI.address,      ethers.utils.solidityKeccak256(        ["uint256", "uint256"],        [recipientAddress, i] // key, slot (solidity)      )    );    console.log(d);  }  // const index = ethers.utils.solidityKeccak256(  //   ["uint256", "uint256"],  //   [recipientAddress, 2] // key, slot  // );  // await setStorageAt(  //   DAI.address,  //   index,  //   toBytes32(ethers.BigNumber.from("41")).toString()  // );  // const balanceAfter = await DAI.balanceOf(recipientAddress);  // console.log(ethers.utils.formatEther(balanceAfter));  // const whaleAddress = whales["DAI"];  // const whaleSigner = await impersonate(whaleAddress);  // const whaleToken = ERC20__factory.connect(tokens["DAI"], whaleSigner);  // const whaleTokenBalance = await whaleToken.balanceOf(whaleAddress);  // await workerSigner.sendTransaction({  //   to: whaleAddress,  //   value: ethers.utils.parseEther("0.2"),  // });  // await transferERC20(whaleToken, recipientAddress, whaleTokenBalance);  // await stopImpersonating(whaleAddress);  // if (!whales[token]) {  //   throw new Error("whale does not exist");  // }  // const whaleAddress = whales[token];  // const erc20 = getERC20(token);  // const whaleBalance = await erc20.balanceOf(whaleAddress);  // if (whaleBalance.eq(0)) {  //   throw new Error("whale does not have balance");  // }  // const whaleSigner = await impersonate(whaleAddress);  // await erc20.connect(whaleSigner).transfer(recipient, whaleBalance);  // await stopImpersonating(whaleAddress);}main()  .then(() => process.exit(0))  .catch((error) => {    console.error(error);    process.exit(1);  });